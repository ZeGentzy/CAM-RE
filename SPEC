Oren-lang is a simple language which is run by the Oren-VM. The Oren-VM has a
(hopefully) infinite stack, a instruction pointer and, of course, your program!

Your program will be composed of a string of omg, why and wtf. All other words
will be ignored. New lines will be ignored.

Omg and why will represent 0 and 1, respectively, meanwhile, wtf will be a token
separator.

Every round, Oren-VM will execute the operation pointed at by the IP if it is a
valid operation, else it will halt.

Here are the Instructions:

PUSH [VAL] - Pushes the value [VAL] onto the stack then increments IP by two
tokens.

POP - Pops the last value (VAL1) off the stack then increments IP by one token.

NAND - Pops the last value (VAL1) and the value before it (VAL2) off the stack,
pushes back (VAL1) NAND (VAL2) then increments IP by one token.

DUPE [COUNT] - Copies then pushes the last [COUNT] values onto the stack then
increments IP by two tokens.

OUT - Pops the last value off the stack (VAL1) then prints it to stdout then
increments IP by one token.

IN - Pushes a value from stdin onto the stack then increments IP by one token.

JMP - Pops the last value (VAL1) off the stack then sets IP to (VAL1)

Conversion Table: 
PUSH | 001
POP  | 010
NAND | 011
DUPE | 100
OUT  | 101
IN   | 110
JMP  | 111

Example programs:

wtf: halt

why wtf: pushes zero onto the stack

why wtf why why why wtf: Pushes seven onto the stack

why wtf why why why wtf why wtf why wtf why why wtf: Pushes seven onto the 
stack, then one then pops both values, nands them to get six which it pushes 
onto the stack.

why wtf: why omg why wtf why why why wtf wtf wtf why wtf wtf why why why wtf: loops forever

why wtf why omg wtf why omg omg wtf why wtf why why why: also loops forever

why why omg wtf: puts whatever the user inputs onto the stack

why omg why wtf: outputs zero (cause stack is empty)

why wtf why why wtf why omg why wtf: outputs three

